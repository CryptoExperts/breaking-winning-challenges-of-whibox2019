#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#pragma GCC optimize ("O1")
typedef unsigned char  u8;
typedef unsigned int   u32;
typedef unsigned short u16;

extern u8 T[11224178];
u8 S[1024];
u8 R[1024];
u32 memory[65536];

int  x[16] = {10,11, 8, 9,   15,12,13,14,     0, 1, 2, 3,    5, 6, 7, 4,};
int  y[16] = { 0, 1, 2, 3,    5, 6, 7, 4,    10,11, 8, 9,    15,12,13,14};
int x2[16] = {15,12,13,14,    0, 1, 2, 3,     5, 6, 7, 4,    10,11, 8, 9};
int y2[16] = { 5, 6, 7, 4,   10,11, 8, 9,    15,12,13,14,     0, 1, 2, 3};
int z[16]  = { 0, 4, 8,12,    1, 5, 9,13,     2, 6,10,14,     3, 7,11,15};


u8 c[11][32] = {
  {0xb8,0x69,0xbe,0x92,0xbd,0x07,0x18,0x59,0x3d,0x9b,0x39,0x58,0x2b,0x6a,0xe6,0x29,0x27,0x23,0x2d,0xc5,0x3a,0x01,0xd6,0x59,0xda,0x09,0xe4,0x67,0x12,0x82,0xe1,0xbb,},
  {0xdc,0x2d,0x0a,0x79,0x48,0xfa,0x61,0xaa,0x2c,0x32,0xc9,0x5c,0xd1,0xc3,0x6b,0x6e,0xa3,0xe3,0x2e,0x35,0xde,0x4d,0x13,0x49,0x70,0x6c,0x26,0xf6,0x7e,0xc1,0xc5,0xbc,},
  {0xb8,0xea,0x76,0x67,0x12,0x2a,0x30,0x81,0xed,0x93,0x77,0x63,0x44,0xe7,0xae,0xef,0xcd,0x10,0x45,0x0c,0x52,0x22,0xc2,0xa3,0xa7,0x1d,0xc3,0xda,0xa8,0x40,0x28,0x10,},
  {0x7a,0x70,0x5c,0xf5,0x18,0xce,0x1b,0xdc,0xc6,0x15,0xcc,0xdb,0x87,0xb7,0xb5,0x92,0x0c,0x00,0xe9,0x4c,0x44,0x40,0xd9,0xfa,0x87,0xdf,0x47,0xdf,0x3d,0x88,0xf9,0x2f,},
  {0xc4,0x81,0x1d,0xde,0x42,0x35,0x8d,0xab,0x46,0x65,0x5a,0x0d,0xdd,0x52,0x59,0xc6,0x99,0x10,0x03,0x60,0xdb,0xc5,0xde,0x56,0x8a,0xc7,0xdf,0x9f,0xd0,0x96,0xeb,0x6a,},
  {0xb3,0x58,0x6b,0xcb,0x24,0xaf,0xcb,0x2d,0x2d,0x54,0x1f,0xcd,0x4d,0xfc,0xe0,0xb6,0xd3,0x98,0xe4,0xca,0x80,0xbc,0xf5,0x55,0x0c,0x83,0x59,0x88,0x1e,0xc3,0x31,0x45,},
  {0xbf,0x76,0xa1,0x1c,0xdf,0x0d,0x5b,0xa9,0x44,0x9f,0x7c,0xe3,0x5b,0x11,0xe4,0x62,0x2e,0x89,0x00,0x8b,0x41,0xc2,0xe9,0xc0,0xd0,0x65,0x8b,0xca,0x31,0x39,0x4f,0x65,},
  {0x28,0x81,0x0a,0x1c,0x59,0x01,0x75,0x2f,0x19,0xf1,0x3b,0x36,0x14,0x8e,0x42,0xa7,0x35,0x24,0x4e,0x13,0xd6,0x02,0xd0,0xef,0x92,0x63,0x20,0x19,0x6c,0x36,0x78,0x99,},
  {0xff,0x44,0x7d,0x17,0xed,0x15,0xcb,0x48,0x9c,0x50,0x45,0xee,0x89,0x44,0x79,0x1e,0x46,0xf8,0xfb,0x46,0xd0,0x07,0xfd,0x19,0x4d,0xb9,0xab,0x7f,0x57,0xdb,0x67,0xd7,},
  {0x73,0x46,0x07,0xe9,0x8f,0x5e,0x73,0xa9,0x46,0x2f,0x64,0x2b,0xd6,0x21,0x37,0x0f,0x97,0x48,0xb9,0x01,0xef,0x52,0x38,0x9e,0xab,0x6d,0x4f,0x32,0x9e,0xcc,0xe5,0x22,},
  {0xdc,0xd8,0x14,0x16,0x36,0x76,0xc5,0x0f,0xb4,0x8b,0x0e,0xe2,0x36,0xf8,0x35,0xff,0x88,0x68,0xb6,0x6f,0x36,0xeb,0xcb,0x0f,0x32,0x48,0xde,0x06,0x07,0x07,0x38,0x64,},
};
u8 d[14*16] = {0x6c,0x8f,0xc9,0x3e,0xae,0xa0,0xd6,0x13,0x49,0x01,0x52,0x6c,0x33,0x7b,0xeb,0x52,0x8f,0xa7,0x47,0x32,0x3f,0xcc,0xc4,0x9d,0x2c,0x6d,0x29,0x14,0x59,0xe6,0x5e,0x9e,0xe6,0x40,0x56,0x3f,0xd3,0xfe,0xb4,0x8e,0x2a,0x0b,0x45,0x8a,0xaa,0x2c,0xfe,0x35,0x2e,0xa8,0xa7,0x31,0xeb,0x1b,0xf9,0x7e,0x78,0x18,0x2c,0x83,0x87,0x78,0xe1,0x6d,0x53,0xc0,0x09,0xca,0x6f,0x66,0x59,0x37,0xe6,0xbf,0xeb,0x59,0x43,0xa5,0x89,0x2e,0xc2,0x5b,0x73,0xaa,0x58,0xe6,0x44,0x89,0x06,0xbd,0xde,0xdb,0x7a,0xaf,0xb7,0xa0,0x4e,0xd3,0xfc,0x7d,0x78,0x88,0x9b,0x9e,0x37,0x1a,0x6e,0xb5,0xb9,0x27,0xd5,0xa0,0xc7,0x56,0x5c,0x6b,0x18,0x1f,0x39,0x87,0x47,0x59,0x94,0x9e,0x27,0x4c,0xe1,0x34,0x09,0x38,0x36,0x98,0xf3,0xcc,0xed,0x2e,0xad,0xdd,0x8b,0x7c,0x64,0x36,0x0d,0x30,0xb1,0xaf,0x95,0xbc,0xea,0x2f,0xb9,0xdf,0xe0,0xe3,0x02,0xa1,0xd8,0x31,0xae,0x85,0x66,0xde,0x56,0x47,0xfe,0xc8,0xed,0xc7,0x16,0x45,0x1a,0x48,0x25,0x7d,0x65,0x86,0x59,0x89,0x5f,0x5c,0xbf,0xd5,0x48,0x07,0x4f,0xc5,0x3d,0xf3,0x54,0x09,0x2f,0x43,0x2f,0x8c,0x5b,0x9b,0xdb,0xe8,0x6e,0xef,0xba,0x0d,0x2b,0x2c,0x7f,0xdd,0x10,0xb7,0xd5,0xf3,0x8e,0xfa,0xa6,0xc0,0x85,0x97,0xae,0x2d,0xfc,0x3a,0x87,0x32,0x29,0x82};
u8 e[14*16] = {};

u8 output_map[256] = {
  0x5b,0xb3,0xd6,0x7c,0xa7,0xd5,0x21,0xa1,0xee,0x19,0x14,0xda,0xa6,0x2b,0x2d,0x8a,0x45,0x73,0x6d,0x37,0x72,0xdb,0xe4,0xaa,0x8c,0x56,0x3c,0x27,0x1f,0xcd,0x64,0x99,
  0x9d,0xc9,0x4c,0x97,0xde,0x78,0xd4,0x59,0xf4,0xe3,0x7a,0x83,0x4f,0x95,0xe1,0xec,0xf6,0x1a,0xf2,0xdc,0x57,0xb5,0x0c,0x6e,0xa8,0xa2,0xd2,0x4e,0xc3,0x4a,0x49,0xf1,
  0x42,0xc1,0x71,0x36,0x40,0xca,0xcf,0x3d,0x61,0x54,0x84,0x91,0x80,0x0b,0x2e,0xae,0x90,0x1c,0x3e,0xcb,0xb8,0x76,0x96,0x20,0x9a,0x55,0x18,0xfd,0xe6,0xb7,0xe8,0xbd,
  0x7e,0x9e,0xf5,0x01,0xdf,0xd3,0xeb,0x8f,0x5f,0x30,0xbb,0x69,0x53,0x6b,0xac,0x9f,0x15,0x0f,0xc2,0x74,0xab,0x65,0x38,0xfc,0xf0,0xd8,0xfb,0xbe,0x04,0x50,0x8b,0x60,
  0x47,0xbc,0xbf,0xd0,0x77,0x7f,0x23,0x31,0x88,0x35,0x51,0xc5,0x25,0x33,0x58,0xb1,0xf7,0x89,0x12,0x87,0x3b,0x67,0xfa,0xaf,0xce,0x02,0x09,0x94,0x9c,0xf3,0x06,0x34,
  0x44,0xc0,0xe2,0x3f,0x6f,0x68,0x0a,0xc7,0xa4,0x4d,0x7b,0xa5,0xd1,0xe7,0x46,0x13,0x32,0x08,0xea,0x5d,0x5e,0x39,0x29,0xb2,0xfe,0xf9,0xff,0x43,0x07,0xb0,0x98,0x5c,
  0x0d,0x62,0x8d,0x7d,0x11,0x70,0x66,0x86,0x48,0x4b,0x16,0xe0,0x2a,0x75,0x17,0xc6,0x8e,0xcc,0x81,0x03,0x00,0xe9,0x24,0x2f,0x1d,0x2c,0xe5,0x5a,0x10,0xad,0x63,0x28,
  0xb4,0x1b,0xd7,0x6a,0x1e,0x6c,0xef,0xa9,0xc4,0x82,0xb9,0x79,0x05,0xa3,0x92,0xdd,0x26,0x93,0x22,0xd9,0x3a,0x0e,0xc8,0xb6,0xa0,0xf8,0x85,0x9b,0x52,0x41,0xed,0xba
};

#define LEN_LOOP_1 679251
u32 loop1_memory  [LEN_LOOP_1];
u32 loop1_mmap    [LEN_LOOP_1];
u8  loop1_op      [LEN_LOOP_1];
extern u32 loop1_operand1[LEN_LOOP_1];
extern u32 loop1_operand2[LEN_LOOP_1];
extern u32 loop1_mask1   [LEN_LOOP_1];
extern u32 loop1_mask2   [LEN_LOOP_1];
extern u32 loop1_output[8*14];


#define LEN_LOOP_2 574005
u32 loop2_memory  [LEN_LOOP_2];
u32 loop2_mmap    [LEN_LOOP_2];
u8  loop2_op      [LEN_LOOP_2];
extern u32 loop2_operand1[LEN_LOOP_2];
extern u32 loop2_operand2[LEN_LOOP_2];
extern u32 loop2_mask1   [LEN_LOOP_2];
extern u32 loop2_mask2   [LEN_LOOP_2];
extern u32 loop2_output[8*14];


void loop(int T_offset, int ptr_offset, int steps) {
  // the loop
  u8 * ptr_T = T + T_offset;
  u32 * ptr_2 = memory + ptr_offset;

  while (steps--) {
    if (*(ptr_T ++) == 0) {
      ptr_2 = memory + *((u16 *)ptr_T);
      ptr_T += 2;
      continue;
    }

    u8 vt = *(ptr_T-1);
    u32 op1 = (u32 )*((u16 *)ptr_T);
    ptr_T += 2;
    u32 op2 = (u32 )*((u16 *)ptr_T);
    ptr_T += 2;
    if (vt == 1) {
      *(ptr_2 ++) = memory[op1] ^ memory[op2];
    } else {
      *(ptr_2 ++) = (memory[op1] ^ - ((u32 )(vt >> 7))) & (memory[op2] ^ - ((u32 )(vt & 1)));
    }
  }
}


void init_memory(int offset) {
  memset(memory, 0, offset*sizeof(u32));
  for (int i = 0; i < offset; i++) {
    for (int j = 0 ; j < 32; j++) { // only loop 2, need all 32 bits???
      memory[i] ^= ( (R[i/8 + j*32] >> ((i^7) & 7) )  & 1) << j;
    }
  }
}

void init_ssa_memory(u32 * mem, int offset) {
  memset(mem, 0, offset*sizeof(u32));
  for (int i = 0; i < offset; i++) {
    for (int j = 0 ; j < 32; j++) { // only loop 2, need all 32 bits???
      mem[i] ^= ( (R[i/8 + j*32] >> ((i^7) & 7) )  & 1) << j;
    }
  }
}

void store_memory(int ret_offset, int num_j) {
  memset(S, 0, 1024);

  for (int j = 0; j < num_j; ++j) {
    for (int i = 0; i < 14; i++) {
      for (int b = 0; b < 8; ++b) {
        int x = i*8+b;
        S[j*32 + i] ^=  ((memory[*((u32 *)(T + ret_offset) + x)] >> j) & 1) << (7 ^ b);
      }
    }
  }
}

void print_memory(int ret_offset, int num_j) {
  for (int i = 0; i < 8*14; i++) {
    printf("%04x,",  0xffff&memory[*((u32 *)(T + ret_offset) + i )] );
    if (i % 8 == 7) {
      printf("\n");
    }
  }
}

void store_ssa_memory(u32 * mem, u32 * output_idx) {
  memset(S, 0, 1024);
  for (int j = 0; j < 32; ++j) {
    for (int i = 0; i < 8*14; i++) {
      S[i/8 + j*32] ^= (((mem[output_idx[i]] >> j) & 1) << ((7 - i) & 7));
    }
  }
}

void loop0() {
  init_memory(132);
  loop(4049189, 132, 375988);
  store_memory(11219849, 16);
}

void loop1() {
  init_ssa_memory(loop1_memory, 240);
  for (int i = 0; i < 240; ++i) {
    loop1_memory[i] &= 0xffff;
  }
  loop_ssa(240, LEN_LOOP_1, loop1_memory, loop1_op, loop1_operand1, loop1_operand2, loop1_mask1, loop1_mask2);
  store_ssa_memory(loop1_memory, loop1_output);
}

void loop1_mod() {
  init_ssa_memory(loop1_memory, 240);
  loop_ssa_mod(240, LEN_LOOP_1, loop1_memory, loop1_op, loop1_operand1, loop1_operand2, loop1_mask1, loop1_mask2);
  store_ssa_memory(loop1_memory, loop1_output);

}

void loop2() {
  for (int j = 0; j < 32; j++) {
    for (int i = 0; i < 14; i++) {
      R[   j*32+i] = S[x[j]*32+i];
      R[14+j*32+i] = S[y[j]*32+i];
    }
    R[28+j*32] = (j<16) ? 0 : 128;
  }

  for (int j = 16; j < 32; j++) {
    for (int i = 0; i < 14; i++) {
      R[+j*32+i] = S[x2[j-16]*32+i];
      R[14+j*32+i] = S[y2[j-16]*32+i];
    }
  }

  init_ssa_memory(loop2_memory, 226);
  loop_ssa(226, LEN_LOOP_2, loop2_memory, loop2_op, loop2_operand1, loop2_operand2, loop2_mask1, loop2_mask2);
  store_ssa_memory(loop2_memory, loop2_output);
}


void loop3() {
  u32 loop3_output[8] = {49558,49181,49628,49356,49584,49632,48938,49359,};

  memset(memory, 0, 240*sizeof(u32));
  for (int i = 0; i < 30; i++) {
    for (int b = 0; b < 8; ++b) {
      for (int slot = 0 ; slot < 16; slot++) {
        memory[i*8+b] ^= ( (R[i + slot*32] >> (b^7) )  & 1) << slot;
      }
    }
  }

  loop(5881179,    240, 456560);

  memset(S, 0, 1024);

  for (int j = 0; j < 16; ++j) {
    for (int b = 0; b < 8; ++b) {
      S[j] ^=  ((memory[loop3_output[b]] >> j) & 1) << (7 ^ b);
    }
  }
}


void AES_128_encrypt(u8 *ct , u8 *pt ) {
  int i,j ;

  // process plaintext
  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 16; ++i) {
      R[j*32+i] = pt[i];
    }
    R[j*32+16] = 16*j;
  }

  // first circuit
  loop0();

  for (j = 0; j < 16; j++) {
    for (i = 0; i < 14; i++) {
      R[j*32+i]    = S[z[j]*32+i];
      R[14+j*32+i] = d[z[j]*14+i];
    }
    R[28+j*32] = c[0][2*j];
    R[29+j*32] = c[0][2*j+1];
  }

  for (int l = 1; l < 10; ++l) {
    loop1();
    loop2();

    for (int j = 0; j < 16; j++) {
      for (int i = 0; i < 14; i++) {
        R[j*32+i]    = S[j*32+i];
        R[14+j*32+i] = S[512+j*32+i];
      }
      R[28+j*32] = c[l][2*j];
      R[29+j*32] = c[l][2*j+1];
    }
  }

  loop1_mod();

  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 14; i++) {
      R[j*32+i] = S[y[j]*32+i];
      R[14+j*32+i] = T[11219486+    j*14+i];
    }

    R[28+j*32] = c[10][j*2];
    R[29+j*32] = c[10][j*2+1];
  }

  loop1();

  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 14; i++) {
      R[j*32+i] = S[(j/4)*32+(j%4)*128+i];
    }
    for (int i = 0; i < 16; i++) {
      R[j*32+i+14] = pt[i];
    }
  }

  loop3();

  for (int i = 0; i < 16; ++i) {
    ct[i] = output_map[S[i]];
  }

  return;

}


// ============================================================================
// HODCA
// ============================================================================

// ----------------------------------------------------------------------------
// Parameters:
// ----------------------------------------------------------------------------
#define NB_TRACES       5000       // Number of traces
#define TARGET_LOOP_INF 18         // Target loop index lower bound
#define TARGET_LOOP_SUP 18         // Target loop index upper bound
#define HODCA_NBO_MIN   2          // Min number of operands in target sets
#define HODCA_NBO_MAX   30         // Max number of operands in target sets
// ----------------------------------------------------------------------------
#define NB_OPERANDS_MAX 30         // Max number of recorded operands per variable
#define MAX_TRACE_SIZE  1000000    // Max size for a trace (error if greater)
#define MEM_SIZE_MAX    679251     // Max size of a loop (= LEN_LOOP_1)

// ----------------------------------------------------------------------------
// Attack mode:
// ----------------------------------------------------------------------------
#define MODE_ODER_FULL  0
#define MODE_ODER_2     2
#define MODE_ODER_3     3     // not implemented yet
#define MODE_ODER_4     4     // not implemented yet
#define MODE_ODER_5     5     // not implemented yet
// ----------------------------------------------------------------------------

int slot_mapping[16] = {0, 5, 10, 15, 1, 6, 11, 12, 2, 7, 8, 13, 3, 4, 9, 14};

// ----------------------------------------------------------------------------
// Global variables:
// ----------------------------------------------------------------------------
u32 acc_nb_operands[MEM_SIZE_MAX];
u32 acc_operands[MEM_SIZE_MAX][NB_OPERANDS_MAX];

u8 pt[NB_TRACES][16];
u8 ct[NB_TRACES][16];

// ----------------------------------------------------------------------------
void pick_plaintext(u8* pt) {
  for (int i = 0; i < 16; i++) {
    pt[i] = rand() % 256;
  }
}

void loop_ssa(int ptr_offset, int steps, u32 * mem, u8 * op, u32 * operand1, u32 * operand2, u32 * mask1, u32 * mask2) {
  for (int i = ptr_offset; i < steps; ++i) {
    u32 op1 = operand1[i];
    u32 op2 = operand2[i];
    if (op[i] == 0) {
      mem[i] = mem[op1] ^ mem[op2];
    } else {
      mem[i] = (mem[op1] ^ mask1[i]) & (mem[op2] ^ mask2[i]);
    }
  }
}


void loop_ssa_mod(int ptr_offset, int steps, u32 * mem, u8 * op, u32 * operand1, u32 * operand2, u32 * mask1, u32 * mask2)
{
  for (int i = ptr_offset; i < steps; ++i) {
    u32 op1 = operand1[i];
    u32 op2 = operand2[i];

    if (op[i] == 0) {
      mem[i] = mem[op1] ^ mem[op2];
    } else {
      mem[i] = (mem[op1] ^ mask1[i]) & (mem[op2] ^ mask2[i]);

      // HODCA: store operands

      if (acc_nb_operands[op1] < NB_OPERANDS_MAX) {
        acc_operands[op1][acc_nb_operands[op1]] = mem[op2];
        acc_nb_operands[op1]++;
      }

      if (acc_nb_operands[op2] < NB_OPERANDS_MAX) {
        acc_operands[op2][acc_nb_operands[op2]] = mem[op1];
        acc_nb_operands[op2]++;
      }

    }
  }
}

void init_operand_recoding() {
  memset(acc_nb_operands, 0, sizeof(u32)*MEM_SIZE_MAX);
}


void generate_traces(int mode)
{
  char  file_name[16][100];
  FILE* trace_file[16];
  u32   trace[MAX_TRACE_SIZE];
  u32   TRACE_SIZE;

  srand(time(NULL));
  time_t start = time(0);

  // open trace files
  for (int byte = 0; byte < 16; byte++) {
    int n = sprintf(file_name[byte], "traces_");

    if (mode == MODE_ODER_FULL) {
      n += sprintf(file_name[byte]+n,"OF_");
    } else {
      n += sprintf(file_name[byte]+n,"O%d_",mode);
    }
    n += sprintf(file_name[byte] + n,
		 "NOp%02d_%02d_NTr%d_byte%02d_loop18.tr",
		 HODCA_NBO_MIN, HODCA_NBO_MAX, NB_TRACES, byte);
    printf("open file %s\n", file_name[byte]);
    trace_file[byte] = fopen(file_name[byte], "wb");
  }

  printf("generating traces...\n");
  for (int t=0; t<NB_TRACES; t++) {
    if ((t % (NB_TRACES/100) == 0) && (t > 0)) {
      for (int byte = 0; byte < 16; byte++) {
	fflush(trace_file[byte]);
      }
      time_t cur = time(0);
      double time = difftime(cur, start) / 60;
      printf("\t%6d / %d  > used time: %3.2f minutes \n", t, NB_TRACES, time);
    }

    // generate plaintext
    pick_plaintext(pt[t]);

    // record operands
    init_operand_recoding();
    AES_128_encrypt(ct[t], pt[t]);

    // compute data-dependency higher-order trace from co-operands
    int j = 0;
    u32 acc;

    for (int i=0; i<MEM_SIZE_MAX; i++) {
      int nbo = acc_nb_operands[i];

      if ((nbo <= HODCA_NBO_MAX) && (nbo >= HODCA_NBO_MIN)) {
        switch (mode) {
	case MODE_ODER_FULL:
          acc = 0;

          for (int k=0; k<nbo; k++) {
	    acc ^= acc_operands[i][k];
	  }

	  if (j >= MAX_TRACE_SIZE) {
	    printf("Trace exceeds max size!!!\n"); exit(0);
	  }

	  trace[j] = acc;
	  j++;
	  break;

	default:
	  printf("Invalid HODCA mode !!\n");
	  exit(0);
	}
      }
    }

    TRACE_SIZE = j;
    // write nb. traces and trace size in file (before first trace)
    if (t == 0) {
      printf("trace size for loop %d: %d\n", 18, TRACE_SIZE);
      for (int byte = 0; byte < 16; byte++) {
	fprintf(trace_file[byte], "%d %d 1\n", NB_TRACES, TRACE_SIZE);
      }
    }

    // write plaintext in file

    for (int byte = 0; byte < 16; byte++) {
      fwrite(pt[t], 1, 16, trace_file[byte]);
      fwrite(ct[t], 1, 16, trace_file[byte]);

      // write trace in file
      for (int i=0; i<TRACE_SIZE; i++) {
	u8 sample = (u8)(trace[i] >> slot_mapping[byte]) & 1;
	fputc(sample, trace_file[byte]);
      }
    }
  }

  // close trace files
  for (int byte = 0; byte < 16; byte++) {
    fclose(trace_file[byte]);
    printf("close file %s\n", file_name[byte]);
  }
}
