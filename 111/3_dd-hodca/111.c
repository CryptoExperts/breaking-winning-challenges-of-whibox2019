#pragma GCC optimize ("O1")

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

typedef unsigned char  u8;
typedef unsigned int   u32;
typedef unsigned short u16;

u8 S[1024];
u8 R[1024];

u32 memory[65536];

#define LEN_LOOP_0 284261
u32 loop0_memory  [LEN_LOOP_0];
extern u8  loop0_op      [LEN_LOOP_0];
extern u32 loop0_operand1[LEN_LOOP_0];
extern u32 loop0_operand2[LEN_LOOP_0];
extern u32 loop0_mask1   [LEN_LOOP_0];
extern u32 loop0_mask2   [LEN_LOOP_0];
u32 loop0_output[8*12] = {284146,284237,283927,284098,284003,284186,284000,284245,284076,284175,283775,283849,284044,284073,284206,284163,283915,284019,284121,284138,284156,284164,284181,284030,284243,284079,284083,283975,284258,283981,284005,284045,284227,284122,284139,284177,284195,283965,283871,284046,284027,284260,284039,283948,284056,284131,284169,284211,284233,283988,284061,284215,284060,284059,284069,284034,284208,284183,284257,284207,284225,283984,284006,284155,284220,284221,283815,283875,284147,283961,284104,284153,284247,284250,284055,284255,284210,283947,283752,284251,284078,284070,283996,284090,283959,283983,283952,283791,283978,283903,284054,283953,283924,283878,283925,283829,};


#define LEN_LOOP_1 520157
u32 loop1_memory  [LEN_LOOP_1];
extern u8  loop1_op      [LEN_LOOP_1];
extern u32 loop1_operand1[LEN_LOOP_1];
extern u32 loop1_operand2[LEN_LOOP_1];
extern u32 loop1_mask1   [LEN_LOOP_1];
extern u32 loop1_mask2   [LEN_LOOP_1];
u32 loop1_output[8*12] = {520118,520015,519886,519942,519997,520152,519915,520117,519879,520068,520050,519890,519809,520137,519932,519992,519965,520106,519953,519975,519991,520054,519797,520089,519907,520155,519544,519931,519814,520011,520027,519660,520075,520119,520047,520059,520062,520056,519850,520044,520064,519853,520041,519868,520016,519956,519821,519766,520123,519677,520102,519909,520135,519935,519979,520104,519474,520128,520141,519960,519968,520150,519978,520003,519877,519592,520094,519927,520081,520138,519651,520095,519829,520092,520025,519918,519974,519789,519891,519881,519989,519987,519727,519702,519838,520144,519940,520067,519724,520028,520156,519818,519604,520083,520037,520096,};


#define LEN_LOOP_2 415220
u32 loop2_memory  [LEN_LOOP_2];
extern u8  loop2_op      [LEN_LOOP_2];
extern u32 loop2_operand1[LEN_LOOP_2];
extern u32 loop2_operand2[LEN_LOOP_2];
extern u32 loop2_mask1   [LEN_LOOP_2];
extern u32 loop2_mask2   [LEN_LOOP_2];
u32 loop2_output[8*12] = {415121,414799,415095,415083,415133,415103,415205,415037,415027,415213,414965,415212,415214,415086,414885,415007,415127,415081,414752,415155,415029,415053,415157,415131,415197,415177,415123,415051,415074,414935,414926,414879,415076,415129,414952,415218,415097,414932,415118,415001,415186,415099,415078,415094,415203,415152,414977,415219,414839,414886,415180,414761,415025,415124,415168,415199,414994,414827,415141,414967,414877,415140,415171,415049,414798,414990,414826,415195,415149,415043,414880,414923,414758,414806,414864,415179,415003,414603,415114,415106,414910,414683,414930,414869,414858,414733,414944,414615,415109,415138,415164,415137,414989,414548,414938,414691};


#define LEN_LOOP_3 317535
u32 loop3_memory  [LEN_LOOP_3];
extern u8  loop3_op      [LEN_LOOP_3];
extern u32 loop3_operand1[LEN_LOOP_3];
extern u32 loop3_operand2[LEN_LOOP_3];
extern u32 loop3_mask1   [LEN_LOOP_3];
extern u32 loop3_mask2   [LEN_LOOP_3];
u32 loop3_output[8] = {317533,317523,317529,317531,317518,317496,317524,317534};

u8 output_map[256] = {
  0xe8,0xad,0xf7,0xdb,0x86,0xa7,0x91,0xdd,0x06,0xfe,0x1c,0xea,0x41,0xac,0x98,0x57,0x28,0x46,0xb6,0xc0,0x0a,0x25,0x49,0x42,0x70,0xa0,0x24,0x87,0x6d,0x0b,0x13,0xbc,
  0x4c,0xaf,0x90,0xa2,0x3f,0xf5,0xe6,0x74,0x95,0x76,0xd1,0xd3,0x51,0xef,0xc2,0x78,0xe5,0x88,0x64,0xff,0xcc,0x18,0x7b,0x8d,0x15,0x09,0x4f,0x33,0x66,0x52,0x5d,0xb0,
  0xbf,0x6c,0x71,0x3c,0xb3,0x0c,0x27,0x31,0x1d,0x83,0xcb,0x5c,0xdf,0xc9,0xd9,0xae,0xb4,0xb5,0x29,0x17,0xe9,0xe1,0x32,0xf6,0x3e,0xbb,0xcf,0x7f,0x45,0x68,0xfd,0x7d,
  0x59,0x7a,0x54,0x4d,0x61,0x26,0x97,0x5f,0x3d,0xb7,0x12,0x85,0x0d,0xe2,0xc8,0x77,0xa6,0x16,0x40,0x21,0x79,0xc5,0xed,0x92,0x50,0x3b,0x2c,0x5e,0x48,0x65,0x99,0xd6,
  0xc4,0x38,0x2e,0x62,0xe7,0x8b,0x9d,0x01,0xb8,0x9a,0xb9,0x36,0xf8,0x8a,0xdc,0x4e,0x02,0x2d,0x4a,0xe0,0xc3,0x30,0xc1,0x93,0xf2,0x0e,0x94,0x67,0x6b,0xc7,0x5b,0xd5,
  0xfa,0x9f,0x00,0xa5,0x23,0xf4,0x44,0x6a,0x8c,0xe3,0xbd,0x35,0xa4,0x7c,0x05,0xcd,0x9b,0x03,0x9c,0xab,0xf0,0xaa,0xd0,0x11,0x22,0xee,0x82,0xd8,0x1e,0x3a,0xce,0x5a,
  0x37,0xf1,0xd2,0x43,0x81,0x72,0xca,0x6f,0x1a,0xde,0x75,0xba,0x8f,0x14,0xd7,0x2f,0xfb,0x89,0x4b,0x6e,0x58,0x07,0xf9,0x63,0xc6,0x80,0x34,0x47,0xec,0x55,0xa1,0xa8,
  0xe4,0x1b,0x8e,0x84,0x56,0x10,0xf3,0x53,0x9e,0x39,0x0f,0x2a,0xa3,0x04,0xeb,0xb1,0x19,0x69,0x08,0x96,0x20,0xda,0x60,0x7e,0xb2,0x1f,0xa9,0xbe,0x73,0x2b,0xfc,0xd4,
};

void loop0(char *pt) {
  int i;

  //read plaintext
  for (i = 0; i < 128; i++) {
    loop0_memory[i] = -((u16)( (pt[i/8] >> ((i%8)^7) )  & 1)) ;
  }

  loop0_memory[16*8+ 0] = 0xff00;
  loop0_memory[16*8+ 1] = 0xf0f0;
  loop0_memory[16*8+ 2] = 0xcccc;
  loop0_memory[16*8+ 3] = 0xaaaa;

  loop_ssa(132, LEN_LOOP_0, loop0_memory, loop0_op, loop0_operand1, loop0_operand2, loop0_mask1, loop0_mask2);

  memset(S, 0, 1024);
  for (int j = 0; j < 16; ++j) {
    for (int i = 0; i < 8*12; i++) {
      S[i/8 + j*32] ^= (((loop0_memory[loop0_output[i]] >> j) & 1) << ((7 - i) & 7));
    }
  }

}

void loop1(int mod) {
  // SBox
  int i, j;

  //inital memory
  memset(loop1_memory, 0, 208*sizeof(u32));
  for (i = 0; i < 8*26; i++) {
    for (j = 0 ; j < 16; j++) { //  only loop 2, need all 32 bits???
      loop1_memory[i] ^= ( (R[i/8 + j*32] >> ((i^7) & 7) )  & 1) << j;
    }
  }

  if (mod == 1) {
    loop_ssa_mod(208, LEN_LOOP_1, loop1_memory, loop1_op, loop1_operand1, loop1_operand2, loop1_mask1, loop1_mask2);
  } else {
    loop_ssa(208, LEN_LOOP_1, loop1_memory, loop1_op, loop1_operand1, loop1_operand2, loop1_mask1, loop1_mask2);
  }

  memset(S, 0, 1024);
  for (int j = 0; j < 16; ++j) {
    for (int i = 0; i < 8*12; i++) {
      S[i/8 + j*32] ^= (((loop1_memory[loop1_output[i]] >> j) & 1) << ((7 - i) & 7));
    }
  }
}


int x[16]  = {10,11, 8, 9,   15,12,13,14,     0, 1, 2, 3,    5, 6, 7, 4,};
int y[16]  = { 0, 1, 2, 3,    5, 6, 7, 4,    10,11, 8, 9,    15,12,13,14};
int x2[16] = {15,12,13,14,    0, 1, 2, 3,     5, 6, 7, 4,    10,11, 8, 9};
int y2[16] = { 5, 6, 7, 4,   10,11, 8, 9,    15,12,13,14,     0, 1, 2, 3};

int z[16]  = { 0, 4, 8,12,    1, 5, 9,13,     2, 6,10,14,     3, 7,11,15};

void loop2() {
  // MixColumn
  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 12; i++) {
      R[   j*32+i] = S[x[j]*32+i];
      R[12+j*32+i] = S[y[j]*32+i];
    }
    R[24+j*32] = 0;
  }

  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 12; i++) {
      R[512+j*32+i] = S[x2[j]*32+i];
      R[524+j*32+i] = S[y2[j]*32+i];
    }
    R[536+j*32] = 128;
  }

  int i, j;

  //inital memory
  memset(loop2_memory, 0, 194*sizeof(u32));
  for (i = 0; i < 194; i++) {
    for (j = 0 ; j < 32; j++) { // only loop 2, need all 32 bits???
      loop2_memory[i] ^= ( (R[i/8 + j*32] >> ((i^7) & 7) )  & 1) << j;
    }
  }

  loop_ssa(194, LEN_LOOP_2, loop2_memory, loop2_op, loop2_operand1, loop2_operand2, loop2_mask1, loop2_mask2);

  memset(S, 0, 1024);
  for (int j = 0; j < 32; ++j) {
    for (int i = 0; i < 8*12; i++) {
      S[i/8 + j*32] ^=  (((loop2_memory[loop2_output[i]] >> j) & 1) << ((7 - i) & 7));

    }
  }
}


void loop3(char *pt) {
  int i, j;


  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 12; i++) {
      R[j*32   +i] = S[z[j]*32+i];
    }
    for (int i = 0; i < 16; i++) {
      R[j*32+12+i] = pt[i];
    }
  }

  //inital memory
  memset(loop3_memory, 0, 224*sizeof(u32));
  for (i = 0; i < 12*8; i++) {
    for (j = 0 ; j < 32; j++) { // only loop 2, need all 32 bits???
      loop3_memory[i] ^= 0xffff & (( (R[i/8 + j*32] >> ((i^7) & 7) )  & 1) << j);
    }
  }
  for (i = 12*8; i < 28*8; i++) {
    for (j = 0 ; j < 32; j++) { // only loop 2, need all 32 bits???
      loop3_memory[i] ^= 0xffff & (( (R[i/8 + j*32] >> ((i^7) & 7) )  & 1) << j);
    }
  }

  loop_ssa(224, LEN_LOOP_3, loop3_memory, loop3_op, loop3_operand1, loop3_operand2, loop3_mask1, loop3_mask2);

  memset(S, 0, 1024);
  for (int j = 0; j < 16; ++j) {
    for (int i = 0; i < 8; i++) {
      S[i/8 + j*32] ^=  (((loop3_memory[loop3_output[i]] >> j) & 1) << ((7 - i) & 7));

    }
  }
}



u8 c[][32] = {
  {0xb5,0x44,0xea,0x9c,0xa5,0x23,0x4a,0x86,0x5b,0x13,0x49,0x38,0x30,0xcc,0x06,0x0d,0xb3,0xaa,0x01,0x6c,0x68,0x25,0x27,0x54,0xce,0x07,0x73,0x9b,0x6d,0x45,0x0b,0x02},
  {0x6a,0xc6,0x63,0x2c,0xc5,0xec,0xf3,0xa7,0xf1,0x4f,0xe3,0xf0,0xfd,0x2c,0xe9,0x0e,0x6a,0x01,0x27,0x9e,0x57,0x94,0xc1,0x49,0x9c,0x3c,0x21,0xa6,0x6d,0xb7,0xa1,0x9e},
  {0xa3,0xfc,0xbc,0xed,0xc4,0x8c,0xfd,0xab,0xbb,0x82,0x38,0xda,0x3f,0xd6,0x30,0xf8,0x4b,0x3f,0xbc,0x41,0xbf,0x4b,0xc9,0x77,0xc4,0xa1,0x6f,0x77,0xb3,0xed,0xfd,0xca},
  {0x28,0x32,0xef,0x98,0xc5,0x5c,0x9d,0x7e,0x85,0x91,0xfe,0xef,0xbb,0x81,0x74,0x9f,0x96,0x91,0x56,0x28,0x9c,0x2d,0xd1,0x7e,0xa0,0xb2,0xec,0x6f,0xa8,0x8f,0x2d,0x46,},
  {0x9b,0x31,0x70,0x0c,0x49,0xfa,0xa2,0x88,0x0f,0x49,0x0f,0x76,0x1a,0xb5,0x74,0xc5,0xe3,0x76,0xee,0x48,0x03,0x3a,0xeb,0xee,0x8d,0x85,0x73,0x01,0x7c,0x40,0x0d,0x79,},
  {0xb9,0xf5,0xdc,0xa2,0x6c,0x0b,0x00,0x64,0x17,0xd7,0xbb,0x7b,0x75,0x4c,0xc5,0xf8,0x88,0x49,0x4d,0x16,0x5c,0x42,0x2b,0xc7,0x68,0x7f,0xff,0x83,0xfb,0x53,0x7d,0x42,},
  {0xd6,0xfc,0x2e,0x63,0x8c,0xc0,0xdd,0x68,0xaa,0x88,0xc4,0x4e,0x8f,0x1c,0xb9,0x89,0x22,0xc7,0x0c,0xd7,0x3b,0x93,0xdb,0x55,0x2a,0x18,0x7f,0x3f,0x88,0x23,0xf8,0x51,},
  {0x5d,0x9e,0x5b,0x4d,0x97,0x81,0xcf,0x49,0xbd,0x98,0xd9,0xb2,0xe6,0xd9,0xc5,0x46,0xf4,0x9e,0x2a,0xb2,0x66,0xec,0xcd,0x9b,0xa4,0x5d,0x6d,0xf4,0x29,0x85,0xf1,0xff,},
  {0x06,0xb2,0x3c,0x38,0x18,0x30,0x2f,0xdf,0xfe,0xa9,0xcd,0x02,0xf2,0x56,0x31,0x86,0x0e,0xb6,0x67,0x23,0x34,0xd9,0x35,0xa7,0x09,0x15,0xa8,0x9e,0x99,0x20,0x4a,0x61,},
  {0x97,0xa1,0x70,0x85,0x56,0x3d,0x4c,0xe7,0xc5,0x25,0x72,0x7d,0xfa,0x39,0x6f,0xe3,0xca,0xdb,0x69,0x89,0x78,0x24,0xc7,0x45,0x9a,0x67,0x25,0x03,0xdb,0x72,0xcb,0x99,},
  {0x5d,0x7e,0xfc,0xa3,0x80,0x28,0xaf,0x52,0xa2,0x33,0x4f,0xa8,0xb4,0x42,0x21,0x4f,0x5b,0x8e,0xce,0x8b,0x1d,0xa7,0xfc,0x6a,0x0f,0x56,0x42,0xda,0x5f,0x33,0xb8,0x05,},
};

u8 d[12*16] = {0x3b,0xa5,0x88,0xf2,0x64,0xf6,0x96,0x86,0x9b,0x64,0xaf,0x45,0xf3,0x4a,0x33,0xbf,0xba,0xb3,0x41,0x7a,0xca,0x03,0xb2,0x07,0x74,0x84,0xba,0x35,0xd0,0x84,0xe2,0x7b,0x8e,0xad,0xfd,0x57,0x3a,0x79,0xe3,0xbe,0x77,0xbf,0x36,0x43,0x3c,0x17,0x9e,0x2a,0xa1,0xc5,0x27,0x9b,0xcc,0xcc,0x0c,0x73,0x8d,0xe5,0x73,0x18,0x7b,0x25,0x2c,0xe8,0xab,0x8c,0x2c,0xaf,0xc9,0xf0,0xaf,0x3f,0x92,0xe5,0xaf,0xd3,0x25,0xf3,0x73,0x11,0x9e,0xda,0x21,0xcd,0xe8,0x45,0x3a,0x8c,0x2e,0x63,0xbf,0xd9,0x13,0xc6,0x51,0x6a,0xfc,0xbd,0x06,0x1e,0x6c,0x84,0x24,0x12,0x91,0x01,0xb7,0x0a,0x8e,0xf6,0x10,0xfc,0x02,0xcf,0x89,0x07,0x00,0x6a,0x35,0xc3,0x6e,0x77,0x09,0xed,0xfc,0x34,0x2c,0x12,0x12,0xfe,0x36,0x25,0xde,0x1b,0xf1,0xc7,0x1a,0xa4,0x75,0x2c,0xc0,0x8b,0x99,0xc5,0x09,0xb7,0xb3,0x53,0x2f,0x6e,0xac,0xb0,0xbb,0x00,0x35,0x12,0xe2,0x8b,0x7e,0x02,0xa2,0x82,0x2d,0x22,0x56,0x4e,0x49,0xd3,0xfc,0x9f,0x1e,0x3f,0x8d,0x72,0xf8,0xbd,0x99,0xcd,0x5b,0xca,0x5f,0x3e,0x6a,0xfa,0xe2,0x7e,0x63,0x40,0x21,0xd0,0xf2,0xd9};
u8 e[12*16] = {0x17,0xad,0x82,0x91,0x29,0x1f,0xe6,0x0a,0x03,0x80,0xdf,0x6c,0x59,0xc3,0x8f,0xdb,0x5e,0xe9,0x33,0xd8,0x1b,0x62,0xdf,0xce,0xfa,0x80,0x55,0x92,0xad,0xac,0x13,0x95,0xc2,0xbe,0xce,0xb7,0xec,0xf3,0x92,0xae,0x0f,0x29,0x68,0x0f,0x5a,0x68,0x13,0x46,0xc4,0x82,0x0c,0x16,0x9c,0x54,0x96,0x69,0x9b,0xe8,0x40,0x29,0xaf,0x87,0x76,0xe5,0xe9,0x97,0x56,0x27,0x77,0x94,0xbd,0xe6,0xa7,0xda,0xed,0x56,0x10,0x2e,0x3e,0x4c,0x95,0x71,0xe7,0x1b,0x4c,0xfd,0x3a,0xad,0xee,0xcd,0x44,0xd4,0x65,0xdc,0x7d,0x66,0xe9,0x74,0x8f,0x6d,0xe5,0x18,0x7a,0xd5,0x46,0x2a,0x1f,0x52,0x5e,0x1c,0x25,0xbc,0x73,0x67,0xa0,0xb4,0x4c,0xb4,0x61,0xf5,0xff,0xc6,0x50,0x33,0xe1,0xfa,0x97,0x12,0x26,0xac,0x51,0x04,0xb6,0x03,0x6f,0x73,0x3e,0x7e,0xc7,0x9c,0x4c,0xea,0x47,0xc6,0x11,0x88,0x18,0x8a,0x89,0x5a,0xf8,0x52,0x7c,0xe9,0x9b,0x5c,0x2d,0x10,0xaa,0x0b,0x95,0x35,0x54,0xf7,0xf4,0x47,0x82,0x59,0xa9,0x50,0x51,0x71,0x32,0xbb,0x27,0xe8,0x40,0xe7,0x05,0xac,0x12,0xb1,0x15,0x76,0xf0,0x5f,0x42,0x87,0xd5,0x69,0xe0,0x09};



void AES_128_encrypt(char *ct , char *pt ) {
  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 16; ++i) {
      R[j*32+i] = pt[i];
    }
    R[j*32+16] = 16*j;
  }

  // inital circuit
  loop0(pt);

  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 12; i++) {
      R[j*32   +i] = S[z[j]*32+i];
      R[j*32+12+i] = d[z[j]*12+i];
    }
    // constant
    R[j*32+24] = c[0][2*j];
    R[j*32+25] = c[0][2*j+1];
  }

  for (int l = 1; l < 10; ++l) {
    loop1(0);
    loop2();

    for (int j = 0; j < 16; j++) {
      for (int i = 0; i < 12; ++i) {
	R[j*32   +i] = S[j*32+i];
	R[j*32+12+i] = S[512+j*32+i];
      }
      R[j*32+24] = c[l][2*j];
      R[j*32+25] = c[l][2*j+1];
    }
  }


  loop1(1);
  for (int j = 0; j < 16; j++) {
    for (int i = 0; i < 12; i++) {
      R[j*32   +i] = S[y[j]*32+i];
      R[j*32+12+i] = e[j*12+i];
    }
    R[j*32+24] = c[10][2*j];
    R[j*32+25] = c[10][2*j+1];
  }

  loop1(0);

  loop3(pt);
  for (int i = 0; i < 16; ++i) {
    ct[i] = output_map[ S[i*32] ];
  }

  return;
}

// ----------------------------------------------------------------------------
// Parameters:
// ----------------------------------------------------------------------------
#define NB_TRACES 5000           // Number of traces
#define TARGET_LOOP_INF 19       // Target loop index lower bound
#define TARGET_LOOP_SUP 19       // Target loop index upper bound
#define HODCA_NBO_MIN 2          // Min number of operands in target sets
#define HODCA_NBO_MAX 30         // Max number of operands in target sets
// ----------------------------------------------------------------------------
#define NB_OPERANDS_MAX 30       // Max number of recorded operands per variable
#define MAX_TRACE_SIZE 1000000   // Max size for a trace (error if greater)
#define MEM_SIZE_MAX 520157      // Max size of a loop (= LEN_LOOP_1)
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Attack mode:
// ----------------------------------------------------------------------------
#define MODE_ODER_FULL  0
#define MODE_ODER_2     2
#define MODE_ODER_3     3     // not implemented yet
#define MODE_ODER_4     4     // not implemented yet
#define MODE_ODER_5     5     // not implemented yet
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Global variables:
// ----------------------------------------------------------------------------
u32 acc_nb_operands[MEM_SIZE_MAX];
u32 acc_operands[MEM_SIZE_MAX][NB_OPERANDS_MAX];

u8 pt[NB_TRACES][16];
u8 ct[NB_TRACES][16];

// ----------------------------------------------------------------------------

int slot_mapping[16] = {0, 5, 10, 15, 1, 6, 11, 12, 2, 7, 8, 13, 3, 4, 9, 14};


void loop_ssa(int ptr_offset, int steps, u32 * mem, u8 * op, u32 * operand1, u32 * operand2, u32 * mask1, u32 * mask2)
{
  for (int i = ptr_offset; i < steps; ++i) {
    u32 op1 = operand1[i];
    u32 op2 = operand2[i];

    if (op[i] == 0) {
      mem[i] = mem[op1] ^ mem[op2];
    } else {
      mem[i] = (mem[op1] ^ mask1[i]) & (mem[op2] ^ mask2[i]);
    }
  }
}


void loop_ssa_mod(int ptr_offset, int steps, u32 * mem, u8 * op, u32 * operand1, u32 * operand2, u32 * mask1, u32 * mask2)
{
  for (int i = ptr_offset; i < steps; ++i) {
    u32 op1 = operand1[i];
    u32 op2 = operand2[i];

    if (op[i] == 0) {
      mem[i] = mem[op1] ^ mem[op2];
    } else {
      mem[i] = (mem[op1] ^ mask1[i]) & (mem[op2] ^ mask2[i]);

      // HODCA: store operands
      if (acc_nb_operands[op1] < NB_OPERANDS_MAX) {
	acc_operands[op1][acc_nb_operands[op1]] = mem[op2];
	acc_nb_operands[op1] ++;
      }

      if (acc_nb_operands[op2] < NB_OPERANDS_MAX) {
	acc_operands[op2][acc_nb_operands[op2]] = mem[op1];
	acc_nb_operands[op2] ++;
      }
    }
  }
}

void init_operand_recoding()
{
  for (int j = 0; j < MEM_SIZE_MAX; ++j) {
    acc_nb_operands[j] = 0;
  }
}

void pick_plaintext(u8* pt)
{
  for (int i = 0; i < 16; i++) {
    pt[i] = (u8) (rand() % 256);
  }
}

void generate_traces(int mode) {
  char  file_name[16][100];
  FILE* trace_file[16];
  u32   trace[MAX_TRACE_SIZE];
  u32   TRACE_SIZE;

  srand(time(NULL));
  time_t start = time(0);

  // open trace files
  for (int byte=0; byte<16; ++byte) {
    int n = sprintf(file_name[byte], "traces_");
    if (mode == MODE_ODER_FULL) {
      n += sprintf(file_name[byte]+n,"OF_");
    } else {
      n += sprintf(file_name[byte]+n,"O%d_",mode);
    }

    n += sprintf(file_name[byte]+n, "NOp%02d%02d_",
		 HODCA_NBO_MIN, HODCA_NBO_MAX);
    n += sprintf(file_name[byte]+n, "NTr%d_byte%02d.tr", NB_TRACES, byte);

    printf("open file %s\n", file_name[byte]);
    trace_file[byte] = fopen(file_name[byte], "wb");
  }

  printf("generating traces...\n");
  for (int t=0; t<NB_TRACES; t++) {
    if ((t % (NB_TRACES/100) == 0) && (t > 0)) {
      time_t cur = time(0);
      double time = difftime(cur, start) / 60;
      printf("\t%6d / %d  > used time: %3.2f minutes \n", t, NB_TRACES, time);
    }

    // generate plaintext
    pick_plaintext(pt[t]);

    // record operands
    init_operand_recoding();
    AES_128_encrypt(ct[t], pt[t]);

    // compute HODCA trace from operands
    int j = 0;
    u32 acc;
    int l = 19;

    for (int i=0; i<MEM_SIZE_MAX; i++) {
      int nbo = acc_nb_operands[i];

      if ((nbo <= HODCA_NBO_MAX) && (nbo >= HODCA_NBO_MIN)) {
	switch (mode) {

	case MODE_ODER_FULL:
	  acc = 0;
	  for (int k=0; k<nbo; k++) {
	    acc ^= acc_operands[i][k];
	  }

	  if (j >= MAX_TRACE_SIZE) {
	    printf("Trace exceeds max size!!!\n"); exit(0);
	  }

	  trace[j] = acc;
	  j++;
	  break;

	default:
	  printf("Invalid HODCA mode !!\n");
	  exit(0);
	}
      }
    }

    TRACE_SIZE = j;

    // write nb. traces and trace size in file (before first trace)
    if (t==0) {
      for (int byte = 0; byte < 16; byte++) {
	printf("trace size for loop %d: %d\n", l, TRACE_SIZE);
	fprintf(trace_file[byte], "%d %d 1\n", NB_TRACES, TRACE_SIZE);
      }
    }

    for (int byte = 0; byte < 16; byte++) {
      // write plaintext & ciphertext in file

      fwrite(pt[t], 1, 16, trace_file[byte]);
      fwrite(ct[t], 1, 16, trace_file[byte]);

      // write trace in file

      for (int i=0; i<TRACE_SIZE; i++) {
	u8 sample = (u8)(trace[i] >> slot_mapping[byte]) & 1;
	fputc(sample,trace_file[byte]);
      }
    }
  }

  // close trace files
  for (int byte = 0; byte < 16; byte++) {
    fclose(trace_file[byte]);
    printf("close file %s\n", file_name[byte]);
  }
}
